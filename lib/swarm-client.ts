import { BACKEND_URL, WS_URL } from "./constants"
import type { Agent, ArchitecturePlan, CodeFile, GraphLink, GraphNode, Message } from "./types"
import type { SSEEventHandler } from "./sse-client"

const COLOR_PALETTE = ["#38bdf8", "#f472b6", "#34d399", "#f97316", "#a855f7", "#22d3ee"]

const slugify = (value: string) =>
  value
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/(^-|-$)+/g, "")

const buildMessage = (payload: any, agent: Agent | undefined): Message => ({
  id: `msg-${payload?.role || "agent"}-${Date.now()}-${Math.random()}`,
  agentId: agent?.id || slugify(payload?.role || "agent"),
  agentName: payload?.role || agent?.name || "Agent",
  agentRole: payload?.role || agent?.role || "Specialist",
  content: payload?.content || "",
  timestamp: Date.now(),
  color: agent?.color || "#f472b6",
})

const buildPlanSummary = (payload: any): ArchitecturePlan => {
  const phases = payload?.execution_plan?.phases || []
  const techEntries = Object.entries(payload?.execution_plan?.tech_stack || {})
    .filter(([, value]) => typeof value === "string" && value)
    .map(([key, value]) => `${key}: ${value}`)

  return {
    projectName: payload?.requirements?.project?.title || "AI Swarm Architecture",
    overview:
      payload?.execution_plan?.overview ||
      payload?.requirements_markdown?.slice(0, 240) ||
      "Generated by the AI Swarm",
    components: phases.map((phase: any) => `${phase?.name || "Phase"}: ${phase?.objective || ""}`),
    techStack: techEntries,
    timeline: phases.map((phase: any) => phase?.name).filter(Boolean).join(" â†’ ") || "",
  }
}

export class SwarmRealtimeClient {
  private handlers: SSEEventHandler
  private sessionId: string | null
  private briefOverride: Record<string, any> | null
  private ws: WebSocket | null = null
  private agentMap = new Map<string, Agent>()

  constructor(handlers: SSEEventHandler, sessionId: string | null, briefOverride: Record<string, any> | null) {
    this.handlers = handlers
    this.sessionId = sessionId
    this.briefOverride = briefOverride
  }

  updateSession(sessionId: string | null) {
    this.sessionId = sessionId
  }

  updateBrief(brief: Record<string, any> | null) {
    this.briefOverride = brief
  }

  private payloadFromBrief(fallbackText?: string) {
    const body: Record<string, any> = {}
    if (this.sessionId) body.session_id = this.sessionId
    if (this.briefOverride) body.brief_override = this.briefOverride
    if (!body.brief_override && !body.session_id && fallbackText) {
      body.brief_override = { project: { summary: fallbackText } }
    }
    return body
  }

  private mapTeamPlan(teamPlan: any) {
    const agents: Agent[] = (teamPlan?.agents || []).map((agent: any, idx: number) => {
      const mapped: Agent = {
        id: agent?.id || `${slugify(agent?.name || "agent")}-${idx}`,
        name: agent?.name || `Agent ${idx + 1}`,
        role: agent?.name || "Specialist",
        color: COLOR_PALETTE[idx % COLOR_PALETTE.length],
        status: "idle",
      }
      this.agentMap.set(mapped.role, mapped)
      return mapped
    })

    const nodes: GraphNode[] = agents.map((agent) => ({
      id: agent.id,
      name: agent.name,
      role: agent.role,
      color: agent.color,
    }))

    const links: GraphLink[] = []
    for (let i = 1; i < agents.length; i++) {
      links.push({ source: agents[i - 1].id, target: agents[i].id, value: 1 })
    }

    return { agents, nodes, links }
  }

  async generateAgents(projectBrief: string) {
    const response = await fetch(`${BACKEND_URL}/projects/team-plan`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(this.payloadFromBrief(projectBrief)),
    })

    if (!response.ok) {
      throw new Error(await response.text())
    }

    const data = await response.json()
    const mapped = this.mapTeamPlan(data.team_plan)
    this.handlers.onAgentsGenerated?.(mapped)
    return data.team_plan
  }

  async startDebate(projectBrief: string, _agents?: Agent[]) {
    if (this.ws) {
      this.disconnect()
    }

    this.handlers.onDebateStart?.()

    return new Promise<void>((resolve, reject) => {
      try {
        this.ws = new WebSocket(WS_URL)
      } catch (error) {
        this.handlers.onError?.(error as Error)
        return reject(error)
      }

      if (!this.ws) {
        return reject(new Error("Unable to establish WebSocket connection"))
      }

      this.ws.onopen = () => {
        this.handlers.onConnect?.()
        const payload = { ...this.payloadFromBrief(projectBrief), rounds: 2 }
        this.ws?.send(JSON.stringify(payload))
        resolve()
      }

      this.ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data)
          this.handleEvent(data)
        } catch (error) {
          console.error("[v0] Failed to parse swarm event", error)
        }
      }

      this.ws.onerror = (event) => {
        console.error("[v0] WebSocket error", event)
        const err = new Error("WebSocket connection error")
        this.handlers.onError?.(err)
        reject(err)
      }

      this.ws.onclose = () => {
        this.handlers.onDisconnect?.()
        this.ws = null
      }
    })
  }

  private handleEvent(event: any) {
    switch (event?.type) {
      case "team_plan": {
        const mapped = this.mapTeamPlan(event.payload)
        this.handlers.onAgentsGenerated?.(mapped)
        break
      }
      case "agent_message": {
        const agent = this.agentMap.get(event.payload?.role)
        this.handlers.onMessage?.(buildMessage(event.payload, agent))
        break
      }
      case "round_complete": {
        // optional hook for UI animations
        break
      }
      case "final_plan": {
        const planSummary = buildPlanSummary(event.payload)
        this.handlers.onPlanReady?.(planSummary)
        const docMarkdown = `${event.payload?.requirements_markdown || ""}\n\n${event.payload?.execution_markdown || ""}`.trim()
        if (docMarkdown) {
          const file: CodeFile = {
            path: "swarm-plan.md",
            content: docMarkdown,
            language: "markdown",
            timestamp: Date.now(),
          }
          this.handlers.onCodeGenerated?.(file)
        }
        this.handlers.onDebateEnd?.()
        this.disconnect()
        break
      }
      case "error":
        this.handlers.onError?.(new Error(event.payload || "Swarm error"))
        this.handlers.onDebateEnd?.()
        this.disconnect()
        break
      default:
        console.log("[v0] Unknown swarm event", event)
    }
  }

  disconnect() {
    if (this.ws) {
      this.ws.close()
      this.ws = null
    }
    this.handlers.onDisconnect?.()
  }
}
